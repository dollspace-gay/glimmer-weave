# Example 23: Lifetimes
# Demonstrates explicit lifetime annotations

# Function returning a borrowed reference
# The returned reference has the same lifetime as the input
chant get_first(borrow list as List<Number>) -> Number then
    yield borrow list[0]
end

# Function with multiple borrowed inputs
# Both inputs must have the same lifetime
chant longer(
    borrow first_text as Text,
    borrow second_text as Text
) -> Text then
    should first_text.length() greater than second_text.length() then
        yield first_text
    otherwise
        yield second_text
    end
end

# Example with struct containing data
form Slice with
    data as List<Number>
    start as Number
    finish as Number
end

chant make_slice(
    borrow list as List<Number>,
    start as Number,
    finish as Number
) -> Slice then
    yield Slice {
        data: list,
        start: start,
        finish: finish
    }
end

# Usage
bind numbers to [10, 20, 30, 40, 50]

# first_num borrows from numbers
bind first_num to get_first(borrow numbers)
VGA.write("First number: " + to_text(first_num))

# Strings with explicit lifetime
bind s1 to "Hello"
bind s2 to "World!"
bind longer_str to longer(borrow s1, borrow s2)
VGA.write("Longer string: " + longer_str)

# Slice borrowing from numbers
bind slice to make_slice(borrow numbers, 1, 3)
VGA.write("Slice from " + to_text(slice.start) + " to " + to_text(slice.finish))

# ERROR: Cannot return reference to local variable
# chant bad_reference() -> Number then
#     bind local to 42
#     yield borrow local  # ERROR: local doesn't live long enough
# end
