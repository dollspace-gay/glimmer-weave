/// Type Variables
///
/// Represents unknown types during type inference. These are distinct from
/// user-written generic parameters (`<T, U>`) and are generated by the compiler.
///
/// ## Examples
///
/// ```text
/// α, β, γ - First three type variables (Greek letters)
/// τ0, τ1, τ2 - Subsequent type variables (tau with index)
/// ```
///
/// ## Usage in Inference
///
/// When the compiler encounters an expression without a known type, it assigns
/// a fresh type variable that will be solved through constraint generation and
/// harmonization (unification).
///
/// ```glimmer
/// bind x to 42           # x :: α, constraint: α = Number
/// bind y to x            # y :: β, constraint: β = α
/// # Solution: α = β = Number
/// ```

use std::fmt;

/// Type variable representing an unknown type
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TypeVar {
    /// Unique identifier for this type variable
    id: usize,

    /// Human-readable name (α, β, γ, τ0, τ1, ...)
    name: String,
}

impl TypeVar {
    /// Create a new type variable with the given ID
    ///
    /// Type variables are named using Greek letters for the first few,
    /// then τ (tau) with numeric suffix for the rest:
    /// - 0 → α (alpha)
    /// - 1 → β (beta)
    /// - 2 → γ (gamma)
    /// - 3 → δ (delta)
    /// - 4 → ε (epsilon)
    /// - 5+ → τ5, τ6, ...
    pub fn fresh(id: usize) -> Self {
        let name = match id {
            0 => "α".to_string(),
            1 => "β".to_string(),
            2 => "γ".to_string(),
            3 => "δ".to_string(),
            4 => "ε".to_string(),
            n => format!("τ{}", n),
        };

        TypeVar { id, name }
    }

    /// Get the unique identifier
    pub fn id(&self) -> usize {
        self.id
    }

    /// Get the human-readable name
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Create a type variable with a custom name (for testing)
    #[cfg(test)]
    pub fn named(id: usize, name: String) -> Self {
        TypeVar { id, name }
    }
}

impl fmt::Display for TypeVar {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.name)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_type_var_naming() {
        assert_eq!(TypeVar::fresh(0).name(), "α");
        assert_eq!(TypeVar::fresh(1).name(), "β");
        assert_eq!(TypeVar::fresh(2).name(), "γ");
        assert_eq!(TypeVar::fresh(3).name(), "δ");
        assert_eq!(TypeVar::fresh(4).name(), "ε");
        assert_eq!(TypeVar::fresh(5).name(), "τ5");
        assert_eq!(TypeVar::fresh(10).name(), "τ10");
        assert_eq!(TypeVar::fresh(100).name(), "τ100");
    }

    #[test]
    fn test_type_var_equality() {
        let v1 = TypeVar::fresh(0);
        let v2 = TypeVar::fresh(0);
        let v3 = TypeVar::fresh(1);

        // Same ID → equal
        assert_eq!(v1, v2);

        // Different ID → not equal
        assert_ne!(v1, v3);
    }

    #[test]
    fn test_type_var_ordering() {
        let v1 = TypeVar::fresh(0);
        let v2 = TypeVar::fresh(1);
        let v3 = TypeVar::fresh(2);

        assert!(v1 < v2);
        assert!(v2 < v3);
        assert!(v1 < v3);
    }

    #[test]
    fn test_type_var_display() {
        let v1 = TypeVar::fresh(0);
        let v2 = TypeVar::fresh(5);

        assert_eq!(format!("{}", v1), "α");
        assert_eq!(format!("{}", v2), "τ5");
    }

    #[test]
    fn test_type_var_hash() {
        use std::collections::HashMap;

        let mut map = HashMap::new();
        let v1 = TypeVar::fresh(0);
        let v2 = TypeVar::fresh(1);

        map.insert(v1.clone(), "first");
        map.insert(v2.clone(), "second");

        assert_eq!(map.get(&v1), Some(&"first"));
        assert_eq!(map.get(&v2), Some(&"second"));
    }

    #[test]
    fn test_type_var_ids() {
        let vars: Vec<_> = (0..10).map(TypeVar::fresh).collect();

        for (i, var) in vars.iter().enumerate() {
            assert_eq!(var.id(), i);
        }
    }
}
